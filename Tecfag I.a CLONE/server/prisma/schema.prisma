// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  name       String
  role       String   @default("USER") // USER or ADMIN
  lastActive DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  mustChangePassword Boolean @default(false)

  // AI Preferences
  jobTitle           String?
  department         String?
  technicalLevel     String?
  communicationStyle String?

  // Access Group relation
  accessGroupId String?
  accessGroup   AccessGroup? @relation(fields: [accessGroupId], references: [id], onDelete: SetNull)

  chatMessages         ChatMessage[]
  archivedChats        ArchivedChat[]
  chatFolders          ChatFolder[]
  tokenUsages          TokenUsage[]
  messageFeedbacks     MessageFeedback[]
  chatSessionContext   ChatSessionContext?
  notificationSettings NotificationSettings?
  notifications        Notification[]

  // Permissions Overrides (null = inherit from group, true = allow, false = block)
  // ===== VISUALIZAÇÃO =====
  canViewChat          Boolean?
  canViewMindMap       Boolean?
  canViewCatalog       Boolean?
  canViewUsers         Boolean?
  canViewMonitoring    Boolean?
  canViewDocuments     Boolean?
  canViewSettings      Boolean?
  canViewNotifications Boolean?
  
  // ===== AÇÕES - MAPA MENTAL =====
  canCreateMindMap     Boolean?
  canEditMindMap       Boolean?
  canDeleteMindMap     Boolean?
  
  // ===== AÇÕES - CATÁLOGO =====
  canCreateCatalog     Boolean?
  canEditCatalog       Boolean?
  canDeleteCatalog     Boolean?
  
  // ===== AÇÕES - USUÁRIOS =====
  canCreateUsers       Boolean?
  canEditUsers         Boolean?
  canDeleteUsers       Boolean?
  
  // ===== AÇÕES - DOCUMENTOS =====
  canUploadDocuments   Boolean?
  canEditDocuments     Boolean?
  canDeleteDocuments   Boolean?
  
  // ===== AÇÕES - CHAT =====
  canArchiveChat       Boolean?
  canDeleteChatHistory Boolean?
  
  // ===== AÇÕES - NOTIFICAÇÕES =====
  canDeleteNotifications Boolean?
  
  // ===== ADMINISTRAÇÃO =====
  canManageAccessGroups Boolean?
  canManageBackups      Boolean?
  canViewTokenCosts     Boolean?
}

// Grupos de acesso com permissões por módulo
model AccessGroup {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  
  // ===== PERMISSÕES DE VISUALIZAÇÃO =====
  canViewChat          Boolean @default(true)
  canViewMindMap       Boolean @default(true)
  canViewCatalog       Boolean @default(true)
  canViewUsers         Boolean @default(false)
  canViewMonitoring    Boolean @default(false)
  canViewDocuments     Boolean @default(false)
  canViewSettings      Boolean @default(false)
  canViewNotifications Boolean @default(true)
  
  // ===== PERMISSÕES DE AÇÃO - MAPA MENTAL =====
  canCreateMindMap     Boolean @default(true)
  canEditMindMap       Boolean @default(true)
  canDeleteMindMap     Boolean @default(false)
  
  // ===== PERMISSÕES DE AÇÃO - CATÁLOGO =====
  canCreateCatalog     Boolean @default(false)
  canEditCatalog       Boolean @default(false)
  canDeleteCatalog     Boolean @default(false)
  
  // ===== PERMISSÕES DE AÇÃO - USUÁRIOS =====
  canCreateUsers       Boolean @default(false)
  canEditUsers         Boolean @default(false)
  canDeleteUsers       Boolean @default(false)
  
  // ===== PERMISSÕES DE AÇÃO - DOCUMENTOS =====
  canUploadDocuments   Boolean @default(false)
  canEditDocuments     Boolean @default(false)
  canDeleteDocuments   Boolean @default(false)
  
  // ===== PERMISSÕES DE AÇÃO - CHAT =====
  canArchiveChat       Boolean @default(true)
  canDeleteChatHistory Boolean @default(true)
  
  // ===== PERMISSÕES DE AÇÃO - NOTIFICAÇÕES =====
  canDeleteNotifications Boolean @default(true)
  
  // ===== PERMISSÕES DE ADMINISTRAÇÃO =====
  canManageAccessGroups Boolean @default(false)
  canManageBackups      Boolean @default(false)
  canViewTokenCosts     Boolean @default(false)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  users       User[]
}

// Feedback de usuários sobre respostas da IA
model MessageFeedback {
  id            String   @id @default(uuid())
  
  // Mensagem avaliada
  messageId     String?  // ID da ChatMessage se ainda existir
  messageContent String  // Cópia do conteúdo (para histórico)
  queryContent   String  // Pergunta que gerou a resposta
  
  // Feedback
  rating        String   // "positive" | "negative"
  category      String?  // "incorrect" | "incomplete" | "confusing" | "too_long" | "other"
  comment       String?
  
  // Contexto
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Metadados
  model         String?  // Qual modelo gerou a resposta
  catalogId     String?
  
  createdAt     DateTime @default(now())
  
  @@index([rating])
  @@index([category])
  @@index([userId])
  @@index([createdAt])
}

// Contexto de sessão de chat para memória inteligente
model ChatSessionContext {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Resumo progressivo da conversa
  contextSummary    String?   // Resumo condensado das últimas N mensagens
  
  // Entidades mencionadas (JSON)
  mentionedEntities String?   // {"machines": ["Seladora X"], "topics": ["manutenção"]}
  
  // Informações já fornecidas (para evitar repetição)
  providedInfo      String?   // JSON com hashes de informações já dadas
  
  // Preferências detectadas durante conversa
  detectedPreferences String? // {"prefersTables": true, "technicalLevel": "advanced"}
  
  // Controle de mensagens
  messageCount      Int      @default(0)
  
  lastUpdated       DateTime @default(now())
  createdAt         DateTime @default(now())
  
  @@index([userId])
}

// Registro de uso de tokens por solicitação
model TokenUsage {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tokens consumidos
  inputTokens   Int
  outputTokens  Int
  totalTokens   Int
  
  // Contexto
  model         String   // ex: "gemini-1.5-pro", "llama-3.3-70b-versatile"
  requestType   String   @default("chat") // "chat", "embedding", etc.
  
  createdAt     DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
}

// Configurações globais de custo por token
model TokenCostSettings {
  id               String   @id @default(uuid())
  
  // Custo por milhão de tokens (em BRL ou moeda configurada)
  inputCostPer1M   Float    @default(0)
  outputCostPer1M  Float    @default(0)
  
  currency         String   @default("BRL")
  
  updatedAt        DateTime @updatedAt
}

model Machine {
  id                String   @id @default(uuid())
  name              String
  category          String
  capacity          String
  model             String
  price             String
  maintenanceStatus String   @default("ok") // ok, attention, critical
  lastMaintenance   String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  specifications MachineSpecification[]
}

model MachineSpecification {
  id        String  @id @default(uuid())
  machineId String
  content   String
  machine   Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)
}

model MindMap {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  nodes MindMapNode[]
}

model MindMapNode {
  id        String  @id @default(uuid())
  mindMapId String
  label     String
  type      String  // machine, process, parameter
  x         Float
  y         Float
  mindMap   MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)

  // Connections from this node
  connectionsFrom MindMapConnection[] @relation("FromNode")
  // Connections to this node
  connectionsTo   MindMapConnection[] @relation("ToNode")
}

model MindMapConnection {
  id         String      @id @default(uuid())
  fromNodeId String
  toNodeId   String
  fromNode   MindMapNode @relation("FromNode", fields: [fromNodeId], references: [id], onDelete: Cascade)
  toNode     MindMapNode @relation("ToNode", fields: [toNodeId], references: [id], onDelete: Cascade)

  @@unique([fromNodeId, toNodeId])
}

model ChatMessage {
  id        String   @id @default(uuid())
  userId    String
  role      String   // user or assistant
  content   String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ArchivedChat {
  id            String   @id @default(uuid())
  userId        String
  title         String
  messagesCount Int
  messages      String   // JSON string of messages array
  createdAt     DateTime @default(now())
  archivedAt    DateTime @default(now())
  folderId      String?
  isPinned      Boolean  @default(false)

  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder ChatFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
}

model ChatFolder {
  id        String   @id @default(uuid())
  userId    String
  name      String
  isDefault Boolean  @default(false)
  order     Int      @default(0)
  createdAt DateTime @default(now())

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  archivedChats ArchivedChat[]
}

model CatalogItem {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  category    String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  documents Document[]
}

model DocumentFolder {
  id        String   @id @default(uuid())
  name      String
  order     Int      @default(0)
  createdAt DateTime @default(now())

  // Hierarquia de pastas
  parentId  String?
  parent    DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children  DocumentFolder[] @relation("FolderHierarchy")

  documents Document[]
}

model Document {
  id           String   @id @default(uuid())
  catalogId    String?  // Tornando opcional para documentos globais
  catalogItem  CatalogItem? @relation(fields: [catalogId], references: [id], onDelete: SetNull)
  
  // Modo de entrega: "text" = RAG normal (extrai texto), "media" = entrega como anexo
  deliveryMode String   @default("text")
  
  // Folder organization
  folderId     String?
  folder       DocumentFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)

  // File information
  fileName     String
  fileType     String
  fileSize     Int
  filePath     String

  // Processing status
  indexed      Boolean  @default(false)
  processingProgress Int @default(0)
  processingError    String?

  // Controle de ativação
  isActive     Boolean  @default(true)  // Permite desativar sem deletar

  // Indexing metadata
  chunkCount   Int?
  totalTokens  Int?

  // Audit
  uploadedBy   String?
  uploadedAt   DateTime @default(now())
  indexedAt    DateTime?

  // Version control
  version      Int      @default(1)
  previousVersionId String?

  chunks       DocumentChunk[]
}

model DocumentChunk {
  id         String   @id @default(uuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Chunk content
  content    String
  chunkIndex Int

  // Embedding vector (stored as JSON array)
  embedding  String

  // Metadata
  metadata   String?  // JSON string for flexible metadata

  createdAt  DateTime @default(now())

  @@index([documentId])
}

// ========== CACHE INTELIGENTE PARA RAG ==========

// Cache de queries para respostas RAG
model QueryCache {
  id             String   @id @default(uuid())
  
  // Query original e identificadores
  queryText      String
  queryHash      String   @unique  // Hash MD5 para exact match
  queryEmbedding String             // Embedding para semantic match
  
  // Resposta cacheada
  response       String
  sources        String?            // JSON com fontes usadas
  
  // Metadados de uso
  hitCount       Int      @default(0)
  catalogId      String?            // Escopo do cache
  userId         String?            // Escopo do usuário (opcional para retrocompatibilidade)
  
  // Invalidação - IDs dos documentos usados na resposta
  documentIds    String             // JSON array de IDs de documentos
  
  // Timestamps
  createdAt      DateTime @default(now())
  lastUsed       DateTime @default(now())
  expiresAt      DateTime
  
  @@index([queryHash])
  @@index([catalogId])
  @@index([userId])
  @@index([expiresAt])
}

// Cache de embeddings para queries
model EmbeddingCache {
  id         String   @id @default(uuid())
  textHash   String   @unique  // Hash MD5 do texto
  embedding  String             // Embedding em JSON
  createdAt  DateTime @default(now())
  
  @@index([textHash])
}

// ========== SISTEMA DE NOTIFICAÇÕES ==========

// Configurações de notificação do usuário
model NotificationSettings {
  id                    String   @id @default(uuid())
  userId                String   @unique
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tipos de notificação habilitados
  systemAlerts          Boolean  @default(true)   // Erros de sistema, status IA
  userAlerts            Boolean  @default(true)   // Novos usuários, logins falhos
  documentAlerts        Boolean  @default(true)   // Uploads, novos docs
  chatAlerts            Boolean  @default(true)   // Feedbacks negativos
  
  // Preferências de entrega
  inAppEnabled          Boolean  @default(true)
  emailEnabled          Boolean  @default(false)  // Para implementação futura
  
  // Frequência
  frequency             String   @default("realtime") // realtime | daily | weekly
  
  // Horário de silêncio
  quietHoursEnabled     Boolean  @default(false)
  quietHoursStart       String?  // "22:00"
  quietHoursEnd         String?  // "08:00"
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// Notificações individuais
model Notification {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type        String    // system | user | document | chat
  category    String    // error | warning | info | success
  title       String
  message     String
  metadata    String?   // JSON com dados adicionais
  
  isRead      Boolean   @default(false)
  readAt      DateTime?
  
  createdAt   DateTime  @default(now())
  
  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}

